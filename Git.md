# Git и GitHub


## О чем эта шпаргалка?  
	
Git — это система контроля версий, которая помогает отслеживать изменения в проекте. Этот инструмент можно использовать как для индивидуальной, так и для командной работы.  
	
Git позволяет сохранять изменения локально и при необходимости возвращаться к предыдущим версиям проекта. Также можно создать удалённую копию на хостинг-платформе, которая работает с Git, и поделиться результатом с другими.xq


## Основные команды. Инициализация репозитория.  
git init - сделать текущую папку репозиторием  
cd - навигация по файловой системе  
pwd - показать текущую директорию  
ls - вывести список файлов  
ls -a - вывести список вместе со скрытыми файлами  
cat <File> - выведет содержимое файла  
git add <File_name> - подготовить файл к коммиту  
git commit -m "Сообщение к коммиту" - Закоммитить изменения  
git remote add origin <URL> - связываем локальный и удаленный репозиторий  
git remote -v - покажет связанные локальные и удаленные репозитории в текущей директории  
git push -u origin master - синхронизируем закоммиченные изменения в локальном репозитории с удаленным репозиторием. <-u> данный флаг нужен только при первичной синхрогизации.  
git log - выводит все коммиты. Для выхода нажать <Q>  
git log --oneline - краткий вывод коммитов (не более 70 символов)  
git commit --amend --no--edit - дополняет последний коммит, добавляя в него файл из staged, при это хэш последнего коммита изменится  
git commit --amend -m - изменение сообщения коммита  
git restore --staged <file> - удаляет файл, который мы по ошибке добавили в staged  
git restore --staged - сбросит всю текущую папку  
git reset --hard <commit hash> - откат до версии, указанной в HEAD, при этом данные всех последующих версий удаляются  
git restore <file> - откатываем файл, если он в статусе modified, но изменения не попали в staged  
git diff - сравнит текущую и последнюю закоммиченную версию файла.   Красным(-) выведет удаленную строку, зеленым(+) добавленную.  
git diff --staged - сравнит файл в состоянии staged (по умолчанию команда сравнивает файл из modified)  
echo <текст> - выводит текст на экран  
echo <текст> >> <File> - добавит текст в файл  
"> и >>" - операторы, которые работают и с другими командами. > перенаправляет вывод в файл, при этом сначала удаляет все содержимое файла. >> Перенаправляет вывод в файл.



## Навигация по коммитам. Статусы файлов.  

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.  
	
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.  

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:  
1. если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;  
2. если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).  
Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.  
Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.  
Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.


Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый). В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.  
Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.  
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.


Статусы файлов в Git:  
1. untracked (англ. «неотслеживаемый»). Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.  
2. staged (англ. «подготовленный»). После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.  
3. tracked (англ. «отслеживаемый»). Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.  
4. mofied (англ. «изменённый»). Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.


Жизненный цикл файла в Git:  
1. Файл только что создали. Git про него ещё ничего не знает. Состояние: untracked.  
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked).  
Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).  
Обратите внимание: staged и modified у одного файла, но у разных его версий.  
Ещё раз выполнили git add. Состояние: staged (+ tracked).  
3. Сделали коммит с помощью git commit. Состояние: tracked.  
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).  
6. Сделали коммит. Состояния: tracked.  
7. Повторили пункты 4−7 много-много раз.


## Общепринятые стандарты коммитов.


### Корпоративные стандарты.
Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения. 
```bash
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"```


### Conventianal commits
Формат коммита <type>: <сообщение>. <type> - это тип изменений. Другие возможные варианты:
1. feat - новый функционал
2. fix - исправление ошибок


### GitHub - стиль
GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать <номер задачи>. Например, вот так: 
```bash
$ git commit -m "Исправить #334, добавить график температуры"```


## Игнорирование файлов в Git


.gitignore - файл, в который нужно записать названия игнорируемых файлов. Правила .gitignore применяются только к файлам в состоянии untracked. Внутри файла .gitignore можно писать следующее:  
1. # комментарий, не читается но полезен  
2. Название файла, который игнорируем
3. * файл будет проигнорирован независимо от того что будет на ее месте, например если мы запишем С:\*\.jpeg , то Git проигнорирует все файлы в формате .jpeg на диске С вне зависимости от их директории внутри диска.  
4. ? соответствует одному любому символу, например file? будет игнорировать file1, file4, fileA итд.  
5. [] аналогично ? соответствует 1 символу, но только тому что указан в скобках. В скобках можно перечислить символы [abs] или указать диапазон [1-4].  
6. / Косая черта, или слеш (/), указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.  
7. ** Функция парных звёздочек (**) похожа на функцию одинарной (*). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.  
8. ! Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).


Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод. Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.
